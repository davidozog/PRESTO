MATLAByrinth
============
A distributed Master/Worker framework for Matlab


INSTALLATION
============
Please read the INSTALL file.


USING MATLAByrinth
==================
After installing, you can use the following command to count the number
of available generic compute nodes on Aciss:

  launch_interactive_qsub count

Then you can launch MATLAByrinth with some number of MATLAB instances less than
the number printed above.  For example, if 4 or more compute nodes are 
available, then you can issue the following command to launch an interactive
session in the resource queue with 4 processes:

  launch_interactive_qsub 4

Then you must launch MATLAByrinth itself with 1 master process and 3 worker 
processes.  This is done by running the following command:

  launch_interactive_Rinth 4

This will launch a single interactive Matlab environment on the current node, 
and 3 other Matlabs running in the background on the other 3 compute nodes.

To send a job to the workers, save a .mat file with objects to be split between
the workers, and another .mat file with objects to be shared among the workers.

In the case of Stingray, this procedure is done in the following files:

  <Stingray_root_dir>/branches/MATLAByrinth/ForwardTL_initStation.m
  <Stingray_root_dir>/branches/MATLAByrinth/ForwardTL_initStation_sub.m



TESTING MATLAByrinth
====================

Besides running Stingray with the .m files above, you should be able to test 
the installation with this simple example.  

First, begin by launching MATLAByrinth as described above with 4 compute nodes.
If the launch worked, you should see 3 lines confirming the 
connection of the workers to the master process:

  Worker connected:  ('192.168.1.22', 33466)
  Worker connected:  ('192.168.1.22', 33467)
  ...

If so, type the following Matlab commands into the interative session:

  m = getenv('MATLABYRINTH');
  load([m, '/src/MATLAByrinth/my_split.mat'])
  load([m, '/src/MATLAByrinth/my_shared.mat'])
  [x y] = send_jobs_to_workers('Rinth_testfunc', 'NETWORK', {'aStation', 'tlMisfit_sub'}, {'srModel'})

When the quick computation is finished, the x.A0 object should contain:

    >>  x.A0

    ans =
    
        34    34
        34    34
    
    
    ans =
    
        35    35
        35    35
    
    
    ans =
    
        36    36
        36    36

and the y object should contain:

>> y(1)

ans = 

        bvec: 31
         res: 31
         ptr: 31
       ttime: 31
       inode: 31
    ray_minz: 31
       niter: 31
      icntTT: 31
       zssqr: 31
       wssqr: 31
       sumsd: 31
       nssqr: 31
      nelsum: 31
      nramat: 31

>> y(2)

ans = 

        bvec: 32
         res: 32
         ptr: 32
       ttime: 32
       inode: 32
    ray_minz: 32
       niter: 32
      icntTT: 32
       zssqr: 32
       wssqr: 32
       sumsd: 32
       nssqr: 32
      nelsum: 32
      nramat: 32

>> y(3)

ans = 

        bvec: 33
         res: 33
         ptr: 33
       ttime: 33
       inode: 33
    ray_minz: 33
       niter: 33
      icntTT: 33
       zssqr: 33
       wssqr: 33
       sumsd: 33
       nssqr: 33
      nelsum: 33
      nramat: 33

